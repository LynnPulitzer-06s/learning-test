"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/backend/deployments directory to retrieve 
  deployment information for LearningTest.sol:
  
  - <root>/frontend/abi/LearningTestABI.ts
  - <root>/frontend/abi/LearningTestAddresses.ts
*/
import { LearningTestAddresses } from "@/abi/LearningTestAddresses";
import { LearningTestABI } from "@/abi/LearningTestABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};
type LearningTestInfoType = {
  abi: typeof LearningTestABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves LearningTest contract metadata for the given EVM `chainId`.
 */
function getLearningTestByChainId(
  chainId: number | undefined
): LearningTestInfoType {
  if (!chainId) {
    return { abi: LearningTestABI.abi };
  }

  const entry =
    LearningTestAddresses[chainId.toString() as keyof typeof LearningTestAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: LearningTestABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: LearningTestABI.abi,
  };
}

export const useLearningTest = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  // States + Refs
  const [scoreHandle, setScoreHandle] = useState<string | undefined>(undefined);
  const [clearScore, setClearScore] = useState<ClearValueType | undefined>(
    undefined
  );
  const clearScoreRef = useRef<ClearValueType>(undefined);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");
  const [studentCount, setStudentCount] = useState<number | undefined>(undefined);
  const [totalHandle, setTotalHandle] = useState<string | undefined>(undefined);
  const [avgHandle, setAvgHandle] = useState<string | undefined>(undefined);
  const [clearTotal, setClearTotal] = useState<ClearValueType | undefined>(undefined);
  const [clearAvg, setClearAvg] = useState<ClearValueType | undefined>(undefined);
  const [hasReward, setHasReward] = useState<boolean>(false);
  const [isEligible, setIsEligible] = useState<boolean>(false);

  const learningTestRef = useRef<LearningTestInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isSubmittingRef = useRef<boolean>(isSubmitting);

  const isDecrypted = scoreHandle && scoreHandle === clearScore?.handle;

  // LearningTest Contract
  const learningTest = useMemo(() => {
    const c = getLearningTestByChainId(chainId);

    learningTestRef.current = c;

    // Only show deployment not found message if chainId is defined and address is missing
    if (chainId !== undefined && !c.address) {
      setMessage(`LearningTest deployment not found for chainId=${chainId}.`);
    } else {
      // Clear message if chainId is undefined or address exists
      setMessage("");
    }

    return c;
  }, [chainId]);

  // Check if deployed
  const isDeployed = useMemo(() => {
    if (!learningTest) {
      return undefined;
    }
    return (Boolean(learningTest.address) && learningTest.address !== ethers.ZeroAddress);
  }, [learningTest]);

  // Can get score
  const canGetScore = useMemo(() => {
    return learningTest.address && ethersReadonlyProvider && ethersSigner && !isRefreshing;
  }, [learningTest.address, ethersReadonlyProvider, ethersSigner, isRefreshing]);

  // Refresh score handle
  const refreshScoreHandle = useCallback(() => {
    console.log("[useLearningTest] call refreshScoreHandle()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !learningTestRef.current ||
      !learningTestRef.current?.chainId ||
      !learningTestRef.current?.address ||
      !ethersReadonlyProvider ||
      !ethersSigner
    ) {
      setScoreHandle(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = learningTestRef.current.chainId;
    const thisLearningTestAddress = learningTestRef.current.address;

    const thisLearningTestContract = new ethers.Contract(
      thisLearningTestAddress,
      learningTestRef.current.abi,
      ethersReadonlyProvider
    );

    // Get student score
    ethersSigner.getAddress().then((address) => {
      return thisLearningTestContract.getStudentScore(address);
    })
      .then((value) => {
        console.log("[useLearningTest] getStudentScore()=" + value);
        if (
          sameChain.current(thisChainId) &&
          thisLearningTestAddress === learningTestRef.current?.address
        ) {
          setScoreHandle(value);
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        console.log("[useLearningTest] getStudentScore() failed, student may not have submitted:", e);
        setScoreHandle(undefined);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });

    // Get student count
    thisLearningTestContract.getStudentCount()
      .then((count) => {
        console.log("[useLearningTest] getStudentCount()=" + count);
        if (sameChain.current(thisChainId)) {
          setStudentCount(Number(count));
        }
      })
      .catch((e) => {
        console.log("[useLearningTest] getStudentCount() failed:", e);
      });

    // Check reward status and eligibility
    ethersSigner.getAddress().then((address) => {
      return Promise.all([
        thisLearningTestContract.hasReward(address),
        thisLearningTestContract.eligible(address),
      ]);
    })
      .then(([rewarded, eligible]) => {
        if (sameChain.current(thisChainId)) {
          setHasReward(Boolean(rewarded));
          setIsEligible(Boolean(eligible));
        }
      })
      .catch(() => {
        // ignore
      });
  }, [ethersReadonlyProvider, ethersSigner, sameChain]);

  // Auto refresh the score handle
  useEffect(() => {
    refreshScoreHandle();
  }, [refreshScoreHandle]);

  // Can decrypt
  const canDecrypt = useMemo(() => {
    return (
      learningTest.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      scoreHandle &&
      scoreHandle !== ethers.ZeroHash &&
      scoreHandle !== clearScore?.handle
    );
  }, [
    learningTest.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    scoreHandle,
    clearScore,
  ]);

  // Decrypt score handle
  const decryptScoreHandle = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!learningTest.address || !instance || !ethersSigner) {
      return;
    }

    // Already computed
    if (scoreHandle === clearScoreRef.current?.handle) {
      return;
    }

    if (!scoreHandle) {
      setClearScore(undefined);
      clearScoreRef.current = undefined;
      return;
    }

    if (scoreHandle === ethers.ZeroHash) {
      setClearScore({ handle: scoreHandle, clear: BigInt(0) });
      clearScoreRef.current = { handle: scoreHandle, clear: BigInt(0) };
      return;
    }

    const thisChainId = chainId;
    const thisLearningTestAddress = learningTest.address;
    const thisScoreHandle = scoreHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("üîì Starting decryption process...");

    const run = async () => {
      const isStale = () =>
        thisLearningTestAddress !== learningTestRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [learningTest.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("‚ùå Unable to create decryption signature. Please try again.");
          return;
        }

        if (isStale()) {
          setMessage("‚ö†Ô∏è Request canceled - chain or signer changed");
          return;
        }

        setMessage("üîê Decrypting your score using FHE...");

        const res = await instance.userDecrypt(
          [{ handle: thisScoreHandle, contractAddress: thisLearningTestAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("‚úÖ Decryption completed successfully!");

        if (isStale()) {
          setMessage("‚ö†Ô∏è Request canceled - chain or signer changed");
          return;
        }

        setClearScore({ handle: thisScoreHandle, clear: res[thisScoreHandle] });
        clearScoreRef.current = {
          handle: thisScoreHandle,
          clear: res[thisScoreHandle],
        };

        setMessage(
          `üéâ Your score: ${clearScoreRef.current.clear} points!`
        );
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    learningTest.address,
    instance,
    scoreHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  // Can submit
  const canSubmit = useMemo(() => {
    return (
      learningTest.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [learningTest.address, instance, ethersSigner, isRefreshing, isSubmitting]);

  // Submit exam
  const submitExam = useCallback(
    (score: number) => {
      if (isRefreshingRef.current || isSubmittingRef.current) {
        return;
      }

      if (!learningTest.address || !instance || !ethersSigner || score < 0 || score > 100) {
        return;
      }

      const thisChainId = chainId;
      const thisLearningTestAddress = learningTest.address;
      const thisEthersSigner = ethersSigner;
      const thisLearningTestContract = new ethers.Contract(
        thisLearningTestAddress,
        learningTest.abi,
        thisEthersSigner
      );

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage(`üìù Preparing to submit your score (${score} points)...`);

      const run = async () => {
        // let the browser repaint before running 'input.encrypt()' (CPU-costly)
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisLearningTestAddress !== learningTestRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisLearningTestAddress,
            thisEthersSigner.address
          );
          input.add32(score);

          setMessage(`üîê Encrypting your score using FHE... (this may take a moment)`);
          // is CPU-intensive (browser may freeze a little when FHE-WASM modules are loading)
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage(`‚ö†Ô∏è Submission canceled - chain or signer changed`);
            return;
          }

          setMessage(`üì§ Submitting encrypted score to blockchain...`);

          // Call contract
          const tx: ethers.TransactionResponse =
            await thisLearningTestContract.submitExam(
              enc.handles[0],
              enc.inputProof
            );

          setMessage(`‚è≥ Waiting for transaction confirmation... (tx: ${tx.hash.slice(0, 10)}...)`);

          const receipt = await tx.wait();

          if (receipt?.status === 1) {
            setMessage(`‚úÖ Score submitted successfully! Your exam is now recorded on-chain.`);
          } else {
            setMessage(`‚ö†Ô∏è Transaction completed but status unclear. Please check your score.`);
          }

          if (isStale()) {
            setMessage(`‚ö†Ô∏è Submission canceled - chain or signer changed`);
            return;
          }

          refreshScoreHandle();
        } catch (e) {
          setMessage(`‚ùå Submission failed: ${e instanceof Error ? e.message : String(e)}`);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      learningTest.address,
      learningTest.abi,
      instance,
      chainId,
      refreshScoreHandle,
      sameChain,
      sameSigner,
    ]
  );

  // Compute encrypted total (contract authorizes caller to decrypt)
  const computeTotalHandle = useCallback(() => {
    if (!learningTest.address || !ethersSigner) return;
    const thisLearningTestAddress = learningTest.address as `0x${string}`;
    const thisAbi = learningTest.abi;
    const c = new ethers.Contract(
      thisLearningTestAddress,
      thisAbi,
      ethersSigner
    );
    setMessage("üìä Computing encrypted total score across all students...");
    const readRunner = ethersReadonlyProvider ?? ethersSigner;
    c.calculateTotalScore()
      .then(async (tx: ethers.TransactionResponse) => {
        await tx.wait();
        setMessage("‚è≥ Transaction confirmed, retrieving encrypted handle...");
        // Get the handle from the transaction receipt events or directly query
        // Since calculateTotalScore returns the handle, we need to get it from the contract
        const cRead = new ethers.Contract(
          thisLearningTestAddress,
          thisAbi,
          readRunner
        );
        const h = await cRead.getLastTotalScoreHandle();
        setTotalHandle(h);
        setMessage(`‚úÖ Encrypted total handle created! Ready to decrypt.`);
      })
      .catch((e: unknown) => {
        setMessage(`‚ùå Failed to compute total: ${String(e)}`);
        console.error("computeTotalHandle error:", e);
      });
  }, [ethersSigner, ethersReadonlyProvider, learningTest.address, learningTest.abi]);

  const decryptTotalHandle = useCallback(async () => {
    if (!instance || !ethersSigner || !learningTest.address || !totalHandle) return;
    const sig: FhevmDecryptionSignature | null = await FhevmDecryptionSignature.loadOrSign(
      instance,
      [learningTest.address as `0x${string}`],
      ethersSigner,
      fhevmDecryptionSignatureStorage
    );
    if (!sig) return;
    const res = await instance.userDecrypt(
      [{ handle: totalHandle, contractAddress: learningTest.address }],
      sig.privateKey,
      sig.publicKey,
      sig.signature,
      sig.contractAddresses,
      sig.userAddress,
      sig.startTimestamp,
      sig.durationDays
    );
    setClearTotal({ handle: totalHandle, clear: res[totalHandle] });
  }, [instance, ethersSigner, learningTest.address, totalHandle, fhevmDecryptionSignatureStorage]);

  // Compute handle for "average" aggregation (contract returns aggregated total; frontend computes public average using studentCount)
  const computeAvgHandle = useCallback(() => {
    if (!learningTest.address || !ethersSigner) return;
    const c = new ethers.Contract(
      learningTest.address,
      learningTest.abi,
      ethersSigner
    );
    const cRead = new ethers.Contract(
      learningTest.address,
      learningTest.abi,
      ethersReadonlyProvider ?? ethersSigner
    );
    setMessage("üìä Computing encrypted aggregate for average calculation...");
    c.calculateAverageScore()
      .then(async (tx: ethers.TransactionResponse) => {
        await tx.wait();
        const h = await cRead.getLastAggregateHandle();
        setAvgHandle(h);
        setMessage("‚úÖ Aggregate handle created! Ready to compute average.");
      })
      .catch((e: unknown) => setMessage(`‚ùå Failed to compute average: ${String(e)}`));
  }, [ethersSigner, ethersReadonlyProvider, learningTest.address, learningTest.abi]);

  const decryptAvgHandle = useCallback(async () => {
    if (!instance || !ethersSigner || !learningTest.address || !avgHandle) return;
    const sig: FhevmDecryptionSignature | null = await FhevmDecryptionSignature.loadOrSign(
      instance,
      [learningTest.address as `0x${string}`],
      ethersSigner,
      fhevmDecryptionSignatureStorage
    );
    if (!sig) return;
    const res = await instance.userDecrypt(
      [{ handle: avgHandle, contractAddress: learningTest.address }],
      sig.privateKey,
      sig.publicKey,
      sig.signature,
      sig.contractAddresses,
      sig.userAddress,
      sig.startTimestamp,
      sig.durationDays
    );
    setClearAvg({ handle: avgHandle, clear: res[avgHandle] });
  }, [instance, ethersSigner, learningTest.address, avgHandle, fhevmDecryptionSignatureStorage]);

  // Check if current user is owner
  const [isOwner, setIsOwner] = useState<boolean>(false);
  const [contractOwner, setContractOwner] = useState<string | undefined>(undefined);

  // Check owner status
  useEffect(() => {
    if (!learningTest.address || !ethersReadonlyProvider || !ethersSigner) {
      setIsOwner(false);
      return;
    }
    const c = new ethers.Contract(
      learningTest.address,
      learningTest.abi,
      ethersReadonlyProvider
    );
    c.owner()
      .then((owner: string) => {
        setContractOwner(owner);
        ethersSigner.getAddress().then((addr) => {
          setIsOwner(addr.toLowerCase() === owner.toLowerCase());
        });
      })
      .catch(() => {
        setIsOwner(false);
      });
  }, [learningTest.address, ethersReadonlyProvider, ethersSigner]);

  // Mark eligible (owner only)
  const markEligible = useCallback(async (addresses: string[]) => {
    if (!learningTest.address || !ethersSigner) return;
    if (addresses.length === 0) {
      setMessage("‚ö†Ô∏è No addresses provided");
      return;
    }
    // Validate and normalize addresses
    const normalizedAddresses = addresses.map(addr => {
      try {
        return ethers.getAddress(addr.trim());
      } catch (e) {
        throw new Error(`Invalid address: ${addr}`);
      }
    });
    const c = new ethers.Contract(
      learningTest.address,
      learningTest.abi,
      ethersSigner
    );
    setMessage(`üëë Marking ${normalizedAddresses.length} student(s) as eligible for rewards...`);
    try {
      const tx = await c.markEligible(normalizedAddresses);
      setMessage(`‚è≥ Transaction submitted (${tx.hash.slice(0, 10)}...). Waiting for confirmation...`);
      await tx.wait();
      setMessage(`‚úÖ Successfully marked ${normalizedAddresses.length} student(s) as eligible!`);
      refreshScoreHandle();
    } catch (e: any) {
      const errorMsg = e?.reason || e?.message || String(e);
      setMessage(`‚ùå Failed to mark eligible: ${errorMsg}`);
      console.error("markEligible error:", e);
    }
  }, [ethersSigner, learningTest.address, learningTest.abi, refreshScoreHandle]);

  // Claim reward NFT (requires eligible and not yet claimed)
  const claimReward = useCallback(async () => {
    if (!learningTest.address || !ethersSigner) return;
    const c = new ethers.Contract(
      learningTest.address,
      learningTest.abi,
      ethersSigner
    );
    setMessage("üéÅ Claiming your Honor NFT reward...");
    try {
      const tx = await c.claimReward();
      setMessage("‚è≥ Waiting for transaction confirmation...");
      await tx.wait();
      setMessage("üéâ Congratulations! Honor NFT successfully claimed!");
      refreshScoreHandle();
    } catch (e) {
      setMessage(`‚ùå Failed to claim reward: ${String(e)}`);
    }
  }, [ethersSigner, learningTest.address, learningTest.abi, refreshScoreHandle]);

  return {
    contractAddress: learningTest.address,
    canDecrypt,
    canGetScore,
    canSubmit,
    submitExam,
    decryptScoreHandle,
    refreshScoreHandle,
    computeTotalHandle,
    decryptTotalHandle,
    computeAvgHandle,
    decryptAvgHandle,
    isDecrypted,
    message,
    clear: clearScore?.clear,
    handle: scoreHandle,
    totalHandle,
    avgHandle,
    clearTotal: clearTotal?.clear,
    clearAvg: clearAvg?.clear,
    isDecrypting,
    isRefreshing,
    isSubmitting,
    isDeployed,
    studentCount,
    hasReward,
    isEligible,
    claimReward,
    isOwner,
    contractOwner,
    markEligible,
  };
};

